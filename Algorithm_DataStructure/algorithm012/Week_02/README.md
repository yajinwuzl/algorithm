学习笔记

###Topic
哈希表、集合、树、二叉树、二叉搜索树、堆、二叉堆、图

以上都属于非线性表结构

###哈希表(HashMap)

概念：哈希表也称为散列表，其是一种数组的扩展；

特性：用的是数组支持按照下标随机访问数据；

哈希函数：它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过哈希函数计算得到的哈希值

哈希函数设计基本要求：

               (1).哈希函数计算得到的散列值是一个非负整数；
               (2).如果 key1 = key2，那 hash(key1) == hash(key2)；
               (3).如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

哈希冲突解决办法：

1.开放寻址法：如果出现了哈希冲突，我们就重新探测一个空闲位置，将其插入;

    实现的探测方法：
               (1).线性探测；
               (2).二次探测；
               (3).双重散列；
               
2.链表法：

    插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。

    查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。

python实现哈希表体现是字典(dict)、set(集合)
###树(Trie)

概念：

根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度以及层数，树的高度。

概念解释：

    节点：树中的每个元素称为节点
    父子关系：相邻两节点的连线，称为父子关系
    根节点：没有父节点的节点
    叶子节点：没有子节点的节点
    父节点：指向子节点的节点
    子节点：被父节点指向的节点
    兄弟节点：具有相同父节点的多个节点称为兄弟节点关系
    节点的高度：节点到叶子节点的最长路径所包含的边数
    节点的深度：根节点到节点的路径所包含的边数
    节点的层数：节点的深度+1（根节点的层数是1）
    树的高度：等于根节点的高度
            
###二叉树

概念：每个节点最多只有2个子节点的树，这两个节点分别是左子节点和右子节点；

扩展：

    满二叉树：除了叶子节点外，每个节点都有左右两个子节点；
    完全二叉树：叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

二叉树遍历：

    (前序遍历)Pre-order:
    # 根-左-右
        def preorder(self, root):
            if root: 
                self.traverse_path.append(root.val) 
                self.preorder(root.left) 
                self.preorder(root.right)
                
    (中序遍历)In-order
    # 左-根-右
        def inorder(self, root):
            if root:
                self.inorder(root.left) 
                self.traverse_path.append(root.val) 
                self.inorder(root.right)
                
    (后序遍历)Post-order
    # 左-右-根
        def postorder(self, root):
            if root:
                self.postorder(root.left) 
                self.postorder(root.right) 
                self.traverse_path.append(root.val)

###二叉搜索树(Binary Search Tree)
概念：也称二叉排序树、有序二叉树(Ordered Binary Tree)、排序二叉树(Sorted Binary Tree)；

特性：1.左子树上所有结点的值均小于它的根结点的值; 2. 右子树上所有结点的值均大于它的根结点的值; 3. 以此类推:左、右子树也分别为二叉查找树

常见操作：

    查找操作:
        (1).先取根节点，如果它等于我们要查找的数据，那就返回;
        (2).如果要查找的数据比根节点的值小，那就在左子树中递归查找;
        (3).如果要查找的数据比根节点的值大，那就在右子树递归查找。
        
    插入操作：
        (1).如果要插入的数据比节点的数据大，并且节点的右子树为空，就将数据直接插到右子节点的位置;
        (2).如果不为空，就再递归遍历右子树，查找插入位置;
        (3).如果要插入的数据比节点数值小，并且节点的左子树为空，就将数据插入到左子节点的位置;
        (4).如果不为空，就再递归遍历左子树，查找插入位置。
        
    删除操作：
        (1).要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null;
        (2).要删除的节点只有一个子节点(只有左子节点或者右子节点),我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就好了。
        (3).要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点，把他替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果有左子结点，那就不是最小节点了).
        
###堆(Heap)
概念：堆是一种特殊的二叉树

满足条件: 堆是一个完全二叉树; 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

堆实现：

    插入操作：
        将元素插入到堆的最后。然后从下向上进行堆化（不断的与父节点比较然后交换；
    删除操作：
        将树的最后一个元素替换掉最大的节点（即根节点），然后从上往下进行堆化（不断的与子节点进行比较然后交换；
        
    # 树的高度不会超过logn，所以堆化是和树的高度成正比，即插入和删除的时间复杂度都是O(logn)。
    
常见形式：二叉堆、斐波那契堆等
###二叉堆(大顶堆)
满足条件: 堆是一个完全二叉树; 堆中每一个节点的值都必须大于等于(=>)其子树中每个节点的值。
实现形式：优先队列

###图
概念：有点有边

常见实现：

    DFS实现(模板)
    visited = set() # 和树中的DFS最大区别
    def dfs(node, visited):
        if node in visited: 
        # terminator
        # already visited
            return
        visited.add(node)
        # process current node here.
        ...
        for next_node in node.children(): 
            if not next_node in visited:
                dfs(next_node, visited)
    
    BFS实现(模板)
    
    def BFS(graph, start, end): 
        queue = []
        queue.append([start])
        
        visited = set() # 和数中的BFS的最大区别
        
        while queue:
            node = queue.pop() 
            visited.add(node)
            process(node)
            nodes = generate_related_nodes(node) 
            queue.push(nodes)